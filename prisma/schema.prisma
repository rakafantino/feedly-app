generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql"
}

model Store {
  id             String          @id @default(uuid())
  name           String
  address        String?
  phone          String?
  email          String?
  description    String?
  isActive       Boolean         @default(true) @map("is_active")
  dailyTarget     Float?          @map("daily_target")
  weeklyTarget    Float?          @map("weekly_target")
  monthlyTarget   Float?          @map("monthly_target")
  expiryNotificationDays Int      @default(30) @map("expiry_notification_days")
  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")
  products       Product[]
  purchaseOrders PurchaseOrder[]
  suppliers      Supplier[]
  transactions   Transaction[]
  users          User[]
  accesses       StoreAccess[]
  customers      Customer[]

  @@map("stores")
}

model User {
  id             String          @id @default(uuid())
  name           String
  email          String          @unique
  password       String
  role           String          @default("CASHIER")
  storeId        String?         @map("store_id")
  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")
  passwordResets PasswordReset[]
  store          Store?          @relation(fields: [storeId], references: [id])
  accesses       StoreAccess[]

  @@map("users")
}

model StoreAccess {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  storeId   String   @map("store_id")
  role      String   @default("CASHIER") // Role specific to this store
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  store     Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([userId, storeId])
  @@map("store_access")
}

model PasswordReset {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_resets")
}

model Product {
  id                 String              @id @default(uuid())
  product_code       String?             @unique @map("product_code") // SKU
  name               String
  category           String
  price              Float
  stock              Float
  unit               String
  supplierId         String?             @map("supplier_id")
  storeId            String              @map("store_id")
  description        String?
  barcode            String?
  threshold          Float?
  isDeleted          Boolean             @default(false) @map("is_deleted")
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @updatedAt @map("updated_at")
  purchase_price     Float?
  expiry_date        DateTime?
  batch_number       String?
  purchase_date      DateTime?
  min_selling_price  Float?
  
  // Unit Conversion Fields
  conversionTargetId String?             @map("conversion_target_id")
  conversionRate     Float?              @map("conversion_rate") // 1 Unit of this -> X Units of Target
  conversionTarget   Product?            @relation("ProductConversion", fields: [conversionTargetId], references: [id]) // The retail product this converts into
  convertedFrom      Product[]           @relation("ProductConversion") // Reverse relation

  // HPP Calculation Details
  hppCalculationDetails Json?            @map("hpp_calculation_details")

  store              Store               @relation(fields: [storeId], references: [id])
  supplier           Supplier?           @relation(fields: [supplierId], references: [id])
  purchaseOrderItems PurchaseOrderItem[]
  items              TransactionItem[]
  batches            ProductBatch[]    @relation("ProductBatches")

  @@unique([barcode, storeId])
  @@map("products")
}

model ProductBatch {
  id            String    @id @default(uuid())
  productId     String    @map("product_id")
  stock         Float     @default(0)
  expiryDate    DateTime? @map("expiry_date")
  batchNumber   String?   @map("batch_number")
  purchasePrice Float?    @map("purchase_price")
  inDate        DateTime  @default(now()) @map("in_date") // Tanggal masuk barang
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  product       Product   @relation("ProductBatches", fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([expiryDate])
  @@map("product_batches")
}

model Supplier {
  id             String          @id @default(uuid())
  code           String          @unique
  name           String
  email          String?
  phone          String?
  address        String?
  storeId        String          @map("store_id")
  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")
  products       Product[]
  purchaseOrders PurchaseOrder[]
  store          Store           @relation(fields: [storeId], references: [id])

  @@map("suppliers")
}

model Transaction {
  id             String            @id @default(uuid())
  total          Float
  paymentMethod  String            @map("payment_method")
  paymentDetails String?           @map("payment_details")
  storeId        String            @map("store_id")
  customerId     String?           @map("customer_id")
  invoiceNumber  String?           @unique @map("invoice_number")
  createdAt      DateTime          @default(now()) @map("created_at")
  updatedAt      DateTime          @updatedAt @map("updated_at")
  items          TransactionItem[]
  store          Store             @relation(fields: [storeId], references: [id])
  customer       Customer?         @relation(fields: [customerId], references: [id])

  // New fields for Debt Tracking
  paymentStatus   String    @default("PAID") @map("payment_status") // PAID, UNPAID, PARTIAL
  amountPaid      Float     @default(0) @map("amount_paid")         // Amount paid upfront
  remainingAmount Float     @default(0) @map("remaining_amount")    // Remaining debt
  dueDate         DateTime? @map("due_date")                          // Jatuh tempo (optional)
  
  debtPayments    DebtPayment[]

  @@map("transactions")
}

model TransactionItem {
  id            String      @id @default(uuid())
  transactionId String      @map("transaction_id")
  productId     String      @map("product_id")
  quantity      Float
  price         Float
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  product       Product     @relation(fields: [productId], references: [id])
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  original_price Float?      @map("original_price") // Harga list normal saat transaksi
  cost_price     Float?      @map("cost_price")     // Harga modal (HPP) saat transaksi

  @@map("transaction_items")
}

// New Model for Payment Logs (Cicilan)
model DebtPayment {
  id            String      @id @default(uuid())
  transactionId String      @map("transaction_id")
  amount        Float
  paymentMethod String      @map("payment_method") // CASH, TRANSFER
  notes         String?
  paidAt        DateTime    @default(now()) @map("paid_at")
  
  // Relations
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  
  @@map("debt_payments")
}

model PurchaseOrder {
  id                String              @id @default(uuid())
  poNumber          String              @unique @map("po_number")
  supplierId        String              @map("supplier_id")
  storeId           String              @map("store_id")
  status            String              @default("draft")
  createdAt         DateTime            @default(now()) @map("created_at")
  updatedAt         DateTime            @updatedAt @map("updated_at")
  estimatedDelivery DateTime?           @map("estimated_delivery")
  notes             String?
  items             PurchaseOrderItem[]
  store             Store               @relation(fields: [storeId], references: [id])
  supplier          Supplier            @relation(fields: [supplierId], references: [id])

  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id              String        @id @default(uuid())
  purchaseOrderId String        @map("purchase_order_id")
  productId       String        @map("product_id")
  quantity        Float
  price           Float
  unit            String        @default("pcs")
  receivedQuantity Float        @default(0) @map("received_quantity")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")
  product         Product       @relation(fields: [productId], references: [id])
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  @@map("purchase_order_items")
}

model Customer {
  id        String   @id @default(uuid())
  storeId   String   @map("store_id")
  name      String
  phone     String?
  address   String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  store        Store         @relation(fields: [storeId], references: [id])
  transactions Transaction[]

  @@index([storeId])
  @@map("customers")
}
