generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql"
}

model Store {
  id             String          @id @default(uuid())
  name           String
  address        String?
  phone          String?
  email          String?
  description    String?
  isActive       Boolean         @default(true) @map("is_active")
  dailyTarget     Float?          @map("daily_target")
  weeklyTarget    Float?          @map("weekly_target")
  monthlyTarget   Float?          @map("monthly_target")
  expiryNotificationDays Int      @default(30) @map("expiry_notification_days")
  
  // Notification Settings
  stockNotificationInterval Int @default(60) @map("stock_notification_interval") // in minutes

  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")
  products       Product[]
  purchaseOrders PurchaseOrder[]
  suppliers      Supplier[]
  transactions   Transaction[]
  notifications  Notification[]
  users          User[]
  accesses       StoreAccess[]
  customers      Customer[]
  stockAdjustments StockAdjustment[]
  expenses       Expense[]

  @@map("stores")
}

model Expense {
  id          String   @id @default(uuid())
  storeId     String   @map("store_id")
  amount      Float
  category    String   // 'RENT', 'SALARY', 'UTILITIES', etc.
  description String?
  date        DateTime @default(now())
  createdById String?  @map("created_by_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  store       Store    @relation(fields: [storeId], references: [id])
  createdBy   User?    @relation(fields: [createdById], references: [id])

  @@index([storeId])
  @@index([date])
  @@map("expenses")
}

model User {
  id             String          @id @default(uuid())
  name           String
  email          String          @unique
  password       String
  role           String          @default("CASHIER")
  storeId        String?         @map("store_id")
  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")
  passwordResets PasswordReset[]
  store          Store?          @relation(fields: [storeId], references: [id])
  accesses       StoreAccess[]
  adjustedStocks StockAdjustment[]
  expenses       Expense[]

  @@map("users")
}

model StoreAccess {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  storeId   String   @map("store_id")
  role      String   @default("CASHIER") // Role specific to this store
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  store     Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([userId, storeId])
  @@map("store_access")
}

model PasswordReset {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_resets")
}

model Product {
  id                 String              @id @default(uuid())
  product_code       String?             @unique @map("product_code") // SKU
  name               String
  category           String
  price              Float
  stock              Float
  unit               String
  supplierId         String?             @map("supplier_id")
  storeId            String              @map("store_id")
  description        String?
  barcode            String?
  threshold          Float?
  isDeleted          Boolean             @default(false) @map("is_deleted")
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @updatedAt @map("updated_at")
  purchase_price     Float?
  hpp_price          Float?              @map("hpp_price") // Clean HPP (Modal + Biaya Langsung)
  expiry_date        DateTime?
  batch_number       String?
  purchase_date      DateTime?
  min_selling_price  Float?
  
  // Unit Conversion Fields
  conversionTargetId String?             @map("conversion_target_id")
  conversionRate     Float?              @map("conversion_rate") // 1 Unit of this -> X Units of Target
  conversionTarget   Product?            @relation("ProductConversion", fields: [conversionTargetId], references: [id]) // The retail product this converts into
  convertedFrom      Product[]           @relation("ProductConversion") // Reverse relation

  // HPP Calculation Details
  hppCalculationDetails Json?            @map("hpp_calculation_details")

  store              Store               @relation(fields: [storeId], references: [id])
  supplier           Supplier?           @relation(fields: [supplierId], references: [id])
  purchaseOrderItems PurchaseOrderItem[]
  items              TransactionItem[]
  notifications      Notification[]
  batches            ProductBatch[]    @relation("ProductBatches")
  stockAdjustments   StockAdjustment[]

  @@unique([barcode, storeId])
  @@map("products")
}

model ProductBatch {
  id            String    @id @default(uuid())
  productId     String    @map("product_id")
  stock         Float     @default(0)
  expiryDate    DateTime? @map("expiry_date")
  batchNumber   String?   @map("batch_number")
  purchasePrice Float?    @map("purchase_price")
  inDate        DateTime  @default(now()) @map("in_date") // Tanggal masuk barang
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  product       Product   @relation("ProductBatches", fields: [productId], references: [id], onDelete: Cascade)
  stockAdjustments StockAdjustment[]

  @@index([productId])
  @@index([expiryDate])
  @@map("product_batches")
}

model Supplier {
  id             String          @id @default(uuid())
  code           String          @unique
  name           String
  email          String?
  phone          String?
  address        String?
  storeId        String          @map("store_id")
  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")
  products       Product[]
  purchaseOrders PurchaseOrder[]
  store          Store           @relation(fields: [storeId], references: [id])

  @@map("suppliers")
}

model Transaction {
  id             String            @id @default(uuid())
  total          Float
  paymentMethod  String            @map("payment_method")
  paymentDetails String?           @map("payment_details")
  storeId        String            @map("store_id")
  customerId     String?           @map("customer_id")
  invoiceNumber  String?           @unique @map("invoice_number")
  createdAt      DateTime          @default(now()) @map("created_at")
  updatedAt      DateTime          @updatedAt @map("updated_at")
  items          TransactionItem[]
  store          Store             @relation(fields: [storeId], references: [id])
  customer       Customer?         @relation(fields: [customerId], references: [id])

  // New fields for Debt Tracking
  paymentStatus   String    @default("PAID") @map("payment_status") // PAID, UNPAID, PARTIAL, WRITTEN_OFF
  amountPaid      Float     @default(0) @map("amount_paid")         // Amount paid upfront
  remainingAmount Float     @default(0) @map("remaining_amount")    // Remaining debt
  dueDate         DateTime? @map("due_date")                          // Jatuh tempo (optional)
  discount        Float     @default(0)                               // Manual Discount (Nominal)
  
  // Write-Off Fields
  writtenOffAt     DateTime? @map("written_off_at")                    // Tanggal write-off
  writtenOffAmount Float?    @map("written_off_amount")                // Jumlah yang dihapus
  writtenOffReason String?   @map("written_off_reason")                // Alasan write-off
  
  debtPayments    DebtPayment[]
  notifications   Notification[]

  @@map("transactions")
}

model TransactionItem {
  id            String      @id @default(uuid())
  transactionId String      @map("transaction_id")
  productId     String      @map("product_id")
  quantity      Float
  price         Float
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  product       Product     @relation(fields: [productId], references: [id])
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  original_price Float?      @map("original_price") // Harga list normal saat transaksi
  cost_price     Float?      @map("cost_price")     // Harga modal (HPP) saat transaksi

  @@map("transaction_items")
}

// New Model for Payment Logs (Cicilan)
model DebtPayment {
  id            String      @id @default(uuid())
  transactionId String      @map("transaction_id")
  amount        Float
  paymentMethod String      @map("payment_method") // CASH, TRANSFER
  notes         String?
  paidAt        DateTime    @default(now()) @map("paid_at")
  
  // Relations
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  
  @@map("debt_payments")
}

model PurchaseOrder {
  id                String              @id @default(uuid())
  poNumber          String              @unique @map("po_number")
  supplierId        String              @map("supplier_id")
  storeId           String              @map("store_id")
  status            String              @default("draft")
  createdAt         DateTime            @default(now()) @map("created_at")
  updatedAt         DateTime            @updatedAt @map("updated_at")
  estimatedDelivery DateTime?           @map("estimated_delivery")
  notes             String?
  // Debt Tracking
  paymentStatus     String              @default("UNPAID") @map("payment_status") // PAID, UNPAID, PARTIAL
  amountPaid        Float               @default(0) @map("amount_paid")
  remainingAmount   Float               @default(0) @map("remaining_amount")
  totalAmount       Float               @default(0) @map("total_amount")
  dueDate           DateTime?           @map("due_date")
  
  items             PurchaseOrderItem[]
  notifications     Notification[]
  store             Store               @relation(fields: [storeId], references: [id])
  supplier          Supplier            @relation(fields: [supplierId], references: [id])

  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id              String        @id @default(uuid())
  purchaseOrderId String        @map("purchase_order_id")
  productId       String        @map("product_id")
  quantity        Float
  price           Float
  unit            String        @default("pcs")
  receivedQuantity Float        @default(0) @map("received_quantity")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")
  product         Product       @relation(fields: [productId], references: [id])
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  @@map("purchase_order_items")
}

model Customer {
  id        String   @id @default(uuid())
  storeId   String   @map("store_id")
  name      String
  phone     String?
  address   String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  store        Store         @relation(fields: [storeId], references: [id])
  transactions Transaction[]

  @@index([storeId])
  @@map("customers")
}

model Notification {
  id            String   @id @default(uuid())
  type          String   // 'STOCK', 'DEBT'
  title         String
  message       String
  isRead        Boolean  @default(false) @map("is_read")
  
  // References
  productId     String?  @map("product_id")
  transactionId String?  @map("transaction_id")
  purchaseOrderId String? @map("purchase_order_id")
  storeId       String   @map("store_id")

  // JSON payload for extra data (currentStock, thresholds, etc)
  metadata      Json?
  
  // Snooze capability
  snoozedUntil  DateTime? @map("snoozed_until")

  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  
  store         Store        @relation(fields: [storeId], references: [id], onDelete: Cascade)
  product       Product?     @relation(fields: [productId], references: [id], onDelete: Cascade)
  transaction   Transaction? @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  purchaseOrder PurchaseOrder? @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  @@index([storeId])
  @@index([isRead])
  @@map("notifications")
}

model StockAdjustment {
  id            String   @id @default(uuid())
  storeId       String   @map("store_id")
  productId     String   @map("product_id")
  batchId       String?  @map("batch_id") // Optional, if specific batch is adjusted
  
  quantity      Float    // Negative for removal, Positive for addition
  type          String   // 'WASTE', 'CORRECTION', 'DAMAGED', 'EXPIRED'
  reason        String?
  
  // Financial impact
  costPerUnit   Float    @map("cost_per_unit") // HPP at time of adjustment
  totalValue    Float    @map("total_value")   // quantity * costPerUnit (negative for loss)
  
  createdAt     DateTime @default(now()) @map("created_at")
  createdById   String?  @map("created_by_id") // Who performed it

  // Relations
  store         Store        @relation(fields: [storeId], references: [id])
  product       Product      @relation(fields: [productId], references: [id])
  batch         ProductBatch? @relation(fields: [batchId], references: [id])
  createdBy     User?        @relation(fields: [createdById], references: [id])

  @@index([storeId])
  @@index([productId])
  @@index([createdAt])
  @@map("stock_adjustments")
}
